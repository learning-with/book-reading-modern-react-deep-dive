## SPA(Single Page Application)란?

싱글페이지 에플리케이션이란 렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 자바스크립트에 의존하는 방식을 의미한다.

사이트 렌더링에 필요한 <body/>내부의 내용을 모두 자바스크립트 코드로 삽입한 이후에 렌더링한다. 또 페이지 전환 시에도 새로운 HTML 페이지를 요청하는게 아니라 자바스크립트에서 다음 페이지의 렌더링에 필요한 정보만 HTTP요청 등으로 가져온 다음 그 결과를 바탕으로 <body/> 내부에 DOM을 추가, 수정, 삭제하는 방법으로 페이지가 전환된다.

즉, 최초에 서버에서 최소한의 데이터를 불러온 이후부터는 이미 가지고 있는 자바스크립트 리소스와 브라우저 API를 기반으로 모든 작동이 이뤄진다.

**최초에 로딩해야 할 자바스크립트 리소스가 커지는 단점이 있지만 한 번 로딩된 이후에는 서버를 거쳐 필요한 리소스를 받아올 일이 적어지기 때문에 사용자에게 훌륭한 UI/UX를 제공한다는 장점**이 있다.
![](https://velog.velcdn.com/images/jutrong/post/c4fd6e5c-6d99-4d52-8e6e-f4218a0f8f2a/image.png)

페이지 전환을 모두 자바스크립트로 한다면 최초에 한 번 모든 리소스를 다운로드하고 나면 이후 페이지를 전환할 때 추가로 리소르를 다운로드하는 시간이 필요 없어진다. 페이지 전체를 새로 렌더링하는 것이 아니라 페이지 전환에 필요한 일부 영역만 다시 그리게 되므로 훨씬 더 매끄러운 UI를 보여줄 수 있다.

## SSR(Server Side Rendering)란?

서버 사이드 렌더링은 최초에 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공하는 방식이다.
![](https://velog.velcdn.com/images/jutrong/post/eabc8cef-1d3c-43cf-98da-7cdb1e247ece/image.png)

### 웹페이지 렌더링의 책임을 어디에 두느냐 ?

```
자바스크립트 번들 -> SPA
서버 -> SSR
```

클라이언트 렌더링은 사용자 기기의 성능에 영향을 받지만 서버 사이드 렌더링은 서버에서 제공하기 때문에 비교적 안정적인 렌더링이 가능하다.

## SSR의 장점

### 최초 페이지 진입이 비교적 빠르다.

사용자가 최초 페이지에 진입했을 때 페이지에 유의미한 정보가 그려지는 시간이 더 빨라질 수 있다.
why ?

일반적으로 서버에서 HTTP 요청을 수행하는 것이 더 빠르고, HTML을 그리는 작업도 서버에서 해당 HTML을 문자열로 미리 그려서 내려주는 것이 클라이언트에서 기존 HTML에 삽입하는 것보다 더 빠르기 때문.

### 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다.

검색 엔진 로봇은 페이지를 보는 것이 아닌 페이지의 정적인 정보를 가져오는 것이 목적이므로 자바스크립트를 다운로드하거나 실행할 필요가 없다.
SPA는 대부분의 작동이 자바스크립트에 의존한다.

즉, 검색 엔진에 제공할 정보를 서버에서 가공해서 HTML 응답으로 제공할 수 있으므로 검색 엔진 최적화에 대응하기가 매우 용이하다.

### 누적 레이아웃 이동이 적다.

누적 레이아웃 이동이란 ?
사용자에게 페이지를 보여준 이후에 뒤늦게 어떤 HTML 정보가 추가되거나 삭제되어 마치 화면이 덜컥거리는 것과 같은 부정적인 사용자 경험을 말한다.

SSR은 API요청이 완전히 완료된 이후에 완성된 페이지를 제공하므로 누적 레이아웃 이동에 관한 문제는 SPA보다 비교적 자유롭다.

### 사용자의 디바이스 성능에 비교적 자유롭다.

자바스크립트 리소스 실행은 사용자의 디바이스에서만 실행되므로 절대적으로 사용자 디바이스 성능에 의존적이다.
그러나 서버 사이드 렌더링을 수행하면 이러한 부담을 서버에 나눌 수 있으므로 조금 더 자유로워질 수 있다.

### 보안에 좀 더 안전하다.

API호출과 같은 인증 같이 사용자에게 노출되면 안되는 민감한 작업도 포함되므로 정상적인 비즈니스 로직을 거치지 않은 상황에서 인증이나 API가 호출되는 것을 항상 방지할 준비가 돼 있어야 한다.
SSR의 경우 인증 혹은 민감한 작업을 서버에서 수행하고 그 결과만 브라우저에 제공해 이러한 보안 위협을 피할 수 있다는 장점이 있다.

## SSR의 단점

### 소스코드를 작성할 때 항상 서버를 고려해야 한다.

서버에서도 실행될 가능성이 있는 코드라면 window에 대한 접근을 최소화해야 하고, window 사용이 불가피하다면 해당 코드가 서버 사이드에서 실행되지 않도록 처리해야 한다. 이러한 서버에 대한 고려는 작성한 코드뿐만 아니라 외부에서 의존하고 있는 라이브러리도 마찬가지이다.

### 적절한 서버가 구축되어 있어야 한다.

SSR은 사용자의 요청을 받아 렌더링을 수행할 서버가 필요하다.
서버를 구축하는 것은 절대 쉬운 일이 아니다.

### 서비스 지연에 따른 문제.

SSR은 서버에서 사용자에게 보여줄 페이지에 대한 렌더링 작업이 끝나기까지는 사용자에게 그 어떤 정보도 제공할 수 없다.
병목 현상이 심해진다면 더 안좋은 사용자 경험을 제공하게 된다.

## SPA 그리고 SSR 무엇이 옳을까?

### 1. 가장 뛰어난 싱글 페이지 애플리케이션은 가장 뛰어난 멀티 페이지 애플리케이션보다 낫다.

최초 페이지 진입 시에 보여줘야 할 정보만 최적화해 요청해서 렌더링하고, 이미지와 같은 중요성 떨어지는 리소스는 게으른 로딩으로 렌더링에 방해되지 않도록 처리하며, 코드 분할 또한 칼같이 지켜서 불필요한 자바스크립트 리소스의 다운로드 및 실행을 방지, 라우팅이 발생하면 변경이 필요한 HTML 영역만 교체해 사용자의 피로감을 최소화 할 수 있다.

### 2. 평균적인 SPA은 평균적인 MPA보다 느리다.

일반적인 SPA은 렌더링과 라우팅에 최적화가 되어 있지 않다면 사용자 기기에 따라 성능이 들쑥날쑥하고, 적절한 성능 최적화도 되어 있지 않을 가능성이 높으므로 멀티 페이지 애플리케이션 대비 성능이 아쉬울 가능성이 크다 (그리고 이러한 최적화는 매우 어렵다.)

## 현대의 서버 사이드 렌더링

요즘의 서버 사이드 렌더링은 먼저, 최초 웹사이트 진입 시에는 서버 사이드 렌더링 방식으로 서버에서 완성된 HTML을 제공받고, 이후 라우팅에서는 서버에서 내려받은 자바스크립트를 바탕으로 마치 싱글 페이지 애플리케이션처럼 작동한다.

1. 초기 페이지 진입이 빠르다.
2. 라우팅을 SPA방식처럼 작동시켜서 빠르다.

## SPA와 SSR 모두 알아야 한다.

웹페이지에서 사용자에게 제공하고 싶은 내용이 무엇인지, 또 어떤 우선순위에 따라 페이지의 내용을 보여줄지를 잘 설계하는 것이 중요하다.

---

## 상태관리는 왜 필요한가?

### 상태가 무엇인가 ?

개발할 때 이야기하는 상태는 어떠한 의미를 지닌 값이며 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값을 의미한다.

### 웹 애플리케이션에서 상태로 분류될 수 있는 것들

#### UI : 상호 작용이 가능한 모든 요소의 현재 값 : 다크/라이트 모드, 라이도를 비롯한 각종 Input, 알림창의 노출 여부 등

#### URL : 브라우저에서 관리되고 있는 상태값, 이 상태는 사용자의 라우팅에 따라 변경된다.

#### 폼(form) : 로딩중인지, 현재 제출됐는지, 접근이 불가능한지, 값이 유효한지 등 모두가 상태로 관리된다.

#### 서버에서 가져온 값 : 서버로 요청을 통해 가져온 값도 상태

웹 서비스에서 점차 다양한 기능이 제곰됨에 따라 웹 내부에서 관리해야 할 상태도 점차 비례해서 증가하고 있다.

## 시장 지배자 Redux 등장

리덕스는 하나의 상태 객체를 스토어에 저장해 두고, 이 객체를 업데이트하는 작업을 디스패치해 업데이트를 수행한다.
리덕스의 등장은 리액트 생태계에 많은 영향을 미치게 됐다. 하나으 ㅣ글로벌 상태 객체를 통해 이 상태를 하위 컴포넌트에 전파할 수 있기 때문에 props drilling을 해결할 수 있고, 스토어가 필요한 컴포넌트라면 단지 connect만 쓰면 스토어에 바로 접근할 수 있다.
그렇다고 리덕스가 마냥 편하기만 한 것은 아니었다.
하고자 하는 일에 비해 보일러플레이트가 너무 많다는 비판의 목소리가 있었다.

## Context API

단순한 레벨의 컴포넌트라면 한 두 단계쯤 props를 넘기는 것은 괜찮았지만 자식 컴포넌트의 깊이가 깊어질수록 props가 컴포넌트를 관통해 버리는 현상이 발생했다. 리덕스를 사용해도 되지만 단순히 상태를 참조하고 싶을 뿐인데 준비해야 하는 보일러플레이트도 부담스러웠다. 이는 번거로울 뿐만 아니라 컴포넌트를 설계할 때 커다란 제약으로 작용했다.

context api는 props로 상태를 넘겨주지 않더라도 원하는 곳에서 Context Provider가 주입하는 상태를 사용할 수 있게 되었다.
그러나 Context API는 상태 관리가 아닌 주입을 도와주는 기능이며, 렌더링을 막아주는 기능 또한 존재하지 않으니 사용할 때 주의가 필요하다. \

## React Query와 SWR

훅과 state의 등장으로 이전에는 볼 수 없던 방식의 상태 관리가 등장한다.
바로 react-query와 SWR이다.

두 라이브러리는 모두 외부에서 데이터를 불러오는 fetch를 관리하는 데 특화된 라이브러리지만, api호출에 대한 상태를 관리하고 있기 때문에 HTTP 요청에 특화된 상태 관리 라이브러리라 볼 수 있다.

## 가장 기본적인 방법 : useState와 useReducer

useState의 등장으로 리액트에서는 여러 컴포넌트에 걸쳐 손쉽게 동일한 인터페이스의 상태를 생성하고 관리할 수 있게 되었다.

useState와 useReducer를 기반으로 하는 사용자 지정 훅의 한계는 명확하다. 훅을 사용할 때마다 컴포넌트별로 초기화되므로 컴포넌트에 따라 서로 다른 상태를 가질 수 밖에 없다. 결론적으로 컴포넌트별로 상태의 파편화를 만들어 버린다. 이렇게 기본적인 useState를 기반으로 한 상태를 지역상태라고 하며, 이 지역 상태는 해당 컴포넌트 내에서만 유효하다는 한계가 있다.

## 상태 관리 라이브러리가 어떤 식으로 동작하는가?

- useState, useReducer가 가지고 있는 한계, 컴포넌트 내부에서만 사용할 수 있는 지역 상태라는 점을 극복하기 위해 외부 어딘가에 상태를 둔다.
  이는 컴포넌트의 최상단 내지는 상태가 필요한 부모가 될 수도 있고, 혹은 격리된 자바스크립트 스코프 어딘가일 수도 있다.
- 이 외부의 상태 변경을 각자의 방식으로 감지해 컴포넌트의 렌더링을 일으킨다.

## 상태 관리 라이브러리 살펴보기

Recoil과 Jotai는 context와 Provider, 그리고 훅을 기반으로 가능한 작은 상태를 효율적으로 관리하는데 초점을 맞추고 있다. 그리고 Zustand는 리덕스와 비슷하게 하나의 큰 스토어를 기반으로 상태를 관리하는 라이브러리다.
Recoil과 Jotai와는 다르게 이 하나의 큰 스토어는 Context가 아니라 스토어가 가지는 클로저를 기반으로 생성되며, 이 스토어의 상태가 변경되면 이 상태를 구독하고 있는 컴포넌트에 전파해 리렌더링을 알리는 방식이다.

### 페이스북이 만든 Recoil

리액트에서 훅의 개념으로 상태 관리를 시작한 최초의 라이브러리 중 하나이며, 최소 상태 개념인 Atom을 처음 리액트 생태계에서 선보이기도 했다.
1.0.0이 배포되지 않아 많은 개발자로 하여금 실제 운영되고 있는 서비스에 Recoil설치를 머뭇거리게 하고 있다.
![](https://velog.velcdn.com/images/jutrong/post/0998d018-f210-41c4-88be-2950319d1ba9/image.png)

애플리케이션의 최상단에 <RecoilRoot/>를 선언해 하나의 스토어를 만들고, atom이라는 상태 단위를 <RecoilRoot/>에서 만든 스토어에 등록한다.
atom은 Recoil에서 관리하는 작은 상태 단위이며, 각 값은 고유한 값인 key를 바탕으로 구별된다. 그리고 컴포넌트는 Recoil에서 제공하는 훅을 통해 atom의 상태 변화를 구독하고, 값이 변경되면 forceUpdate 같은 기법을 통해 리렌더링을 실행해 최신 atom 값을 가져오게 된다.

selector를 필두로 다양한 비동기 작업을 지원하는 API를 제공하고 있기 때문에 리덕스와 달리 redux-saga, redux-thunk 등 추가적인 미들웨어를 사용하지 않더라도 비동기 작업을 수월하게 처리할 수 있다.

한 가지 불확신한 점을 정식 버전인 1.0.0이 출시가 안되었다는 점이다.
안정적인 서비스를 만들고자 하는 개발자들에게 선뜻 채택하기 어렵게 만드는 큰 걸림돌이다.

### Recoil에서 영감 받은 그러나 조금 더 유연한 Jutai

리코일의 atom모델에 영감을 받아 만들어진 상태 관리 라이브러리이다.
리액트 Context의 문제점인 불필요한 리렌더링이 일어난다는 문제를 해결하고자 설계돼 있으며, 추가적으로 개발자들이 메모이제이션이나 최적화를 거치지 않아도 리렌더링이 발생되지 않도록 설계돼 있다.

Recoil에서 많은 영감을 받은 만큼 유사한 면이 많아 보임과 동시에 리코일이 가지고 있는 몇 가지 한계점을 극복하기 위한 노력이 엿보인다.

recoil의 atom 개념을 도입하면서도 API가 간결하다는 점을 꼽을 수 있다. Recoil의 atom에서는 각 상태값이 모두 별도의 키를 필요로 하기 때문에 이 키를 별도로 관리해야 하는데, Jotai는 이러한 부분을 추상화해 사용자가 키를 관리할 필요가 없다. Jotai가 별도의 문자열 키가 없이도 각 값들을 관리할 수 있는 것은 객체의 참조를 통해 값을 관리하기 때문이다.

Jotai에서는 selector가 없이도 atom만으로 atom 값에서 또 다른 파생된 상태를 만들 수 있다.

리코일 대비 여러 가지 장점으로 인해 리코일의 atom 형태의 상태 관리를 선호하지만, 아직 정식 버전이 출시되지 않아 사용이 망설여지는 많은 개발자들이 Jotai를 채택해 개발하고 있다.

### 작고 빠르며 확장에도 유연한 Zustand

하나의 스토어를 중앙 집중형으로 활용해 이 스토어 내부에서 상태를 관리한다.

Zunstand는 특별히 많은 코드를 작성하지 않아도 빠르게 스토어를 만들고 사용할 수 있다는 큰 장점이 있다. 스토어를 만들고 이 스토어에 파생된 값을 만드는 데 단 몇 줄의 코드면 충분하다. 이는 리덕스 대비 확실히 구별되는 특징으로 볼 수 있으며, 간단하고 빠르게 상태를 정의할 수 있어 상태를 관리하는 입장에서 한결 가볍고 편리하다.

또한 Zustand는 리덕스와 마찬가지로 미들웨어를 지원한다. 스토어 데이터를 영구히 보존할 수 있는 persist, 복잡한 객체를 관리하기 쉽게 도와주는 immer, 리덕스와 함께 사용할 수 있는 리덕스 미들웨어 등 여러 가지 미들웨어를 제공해 필요한 미들웨어를 사용할 수 있게 도와준다.

## 결론

![](https://velog.velcdn.com/images/jutrong/post/72b62a0c-9eac-41d4-bcd9-c846a0be1650/image.png)
각 라이브러리별로 특징을 잘 파악하고, 현재 애플리케이션의 상황과 철학에 맞는 상태관리 라이브러리를 적절하게 선택해 사용한다면 효율적인 애플리케이션을 만드는 데 도움이 될 것이다.

npm에서 제공하는 모든 라이브러리와 마찬가지로 메인테이너가 많고 다운로드가 활발하며 이슈가 관리가 잘되고 있는 라이브러리를 선택하는 것이 좋다.
