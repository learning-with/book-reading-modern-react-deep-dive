# 10. 리액트 17과 18의 변경 사항 살펴보기
## 10.1 리액트 17 버전 살펴보기
리액트 16 -> 17의 경우 기존에 사용하던 코드의 수정을 필요로하는 호환성이 깨지는 변경사항을 최소화함
### 10.1.1 리액트의 점진적인 업그레이드
0.3.0부터 16 버전까지 유의적 버전 전략에 맞춰 업데이트되고 있었음

새로운 주 버전이 릴리스되면 이전 버전에서의 API 제공을 완전히 중단해 버리고, 전체 애플리케이션을 새롭게 업그레이드하기를 요구

어떠한 API 수정이 있는지 확인해서 적용해야하며, 지원을 중단한 API를 어떻게 고쳐야할지 고민 과정이 필요

리액트 17 버전부터는 점진적인 업그레이드 가능

전체 애플리케이션 트리는 리액트 17이지만 일부 트리와 컴포넌트에 대해서만 리액트 18을 선택하는 점진적인 버전업이 가능해짐

but 한꺼번에 업그레이드가 불가능한 상태에서만 차선택. 한꺼번에 업데이트하는게 복잡성 감소 측면에서 좋음

### 10.1.2 이벤트 위임 방식의 변경
#### 이벤트의 단계
1. capture: 이벤트 핸들러가 트리 최상단 요소에서부터 시작해서 실제 이벤트가 발생한 타깃 요소까지 내려감
2. target: 이벤트 핸들러가 타깃 노드에 도달. 이벤트가 호출됨
3. bubbling: 이벤트가 발생한 요소에서부터 시작해 최상위 요소까지 다시 올라감

리액트 16 버전까지의 경우, 이벤트 핸들러를 document에 연결해서 이벤트 위임

리액트 17 버전부터 이벤트 핸들러를 리액트 컴포넌트 최상단 트리, 루트 요소로 이벤트 위임 변경

점진적 업그레이드 지원 및 다른 바닐라 자바스크립트 코드 또는 jQuery 등이 혼재돼 있는 경우 혼란을 방지하기 위해서

document의 경우 리액트 컴포넌트 내에서 e.stopPropagation을 실행해도 이미 모든 이벤트가 document로 올라가 있기 때문에 이벤트 전파가 진행됨

이벤트를 리액트 컴포넌트 트리 수준으로 격리하여 이벤트 버블링으로 인한 혼선을 방지
### 10.1.3 import REact from 'react'가 더 이상 필요없다: 새로운 JSX transform
```
const Component = {
  <div>
    <span>hello world</span>
  </div?
}

// 구버전 JSX 변환
var Component = React.createElement(
  'div',
  null,
  React.createElement('span', null, 'hello world'),
)

// 17 버전 JSX 변환
'use strict'

var _jsxRuntime = require('react/jsx-runtime')

var Component = (0, _jsxRuntime.jsx)('div', {
  children: (0, _jsxRuntime.jsx)('span', {
    children: 'hello world',
  }),
})
```
### 10.1.4 그 밖의 주요 변경 사항
#### 이벤트 풀링 제거
- 이벤트 풀링 시스템
  1. 이벤트 핸들러가 이벤트를 발생시킴
  2. 합성 이벤트 풀에서 합성 이벤트 객체에 대한 참조를 가져옴
  3. 이 이벤트 정보를 합성 이벤트 객체에 넣어줌
  4. 유저가 지정한 이벤트 리스너가 실행됨
  5. 이벤트 객체가 초기화되고 다시 이벤트 풀로 돌아옴
SyntheticEvent는 브라우저의 기본 이벤트를 한 번 더 감싼 이벤트 객체로, 이벤트가 발생할 때마다 새로 이벤트를 만들어 메모리 할당 작업이 일어났음

서로 다른 이벤트 간에 이벤트 객체를 재사용하고, 재사용하는 사이에 모든 이벤트 필드를 null로 변경하여 에러를 발생시켜 e.persist를 통해 비동기가 필요했음

#### useEffect 클린업 함수의 비동기 실행
리액트 16 버전까지 useEffect의 클린업함수가 동기적으로 실행되어 종료 전까지 다른 작업을 방해해 불필요한 성능 저하

화면이 업데이트가 완전히 끝난 이후에 클린업 함수가 실행되도록 바뀜
#### 컴포넌트의 undefined 반환에 대한 일관적인 처리
리액트 16과 17 버전은 컴포넌트 내부에서 undefined를 반환하면 오류 발생

리액트 16에서 forwardRef나 memo에서 undefined를 반환하는 경우 에러를 발생시키지 않았음 => 17 버전에서는 정상적으로 에러 발생

리액트 18부터는 undefined를 반환해도 에러가 발생하지 않음
### 10.1.5 정리
## 10.2 리액트 18 버전 살펴보기
### 10.2.1 새로 추가된 훅 살펴보기
#### useId
컴포넌트별로 유니크한 값을 생성하는 새로운 훅

하나의 컴포넌트가 여러 군데에서 재사용되는 경우/ 컴포넌트 트리에서 컴포넌트가 가지는 모든 값이 겹치지 않고 다 달라야한다는 제약/ SSR hydration에서 서버와 클라이언트에서 동일한 값을 가져야 에러가 발생하지 않아 고려해야했음

useId를 사용하면 클라이언트와 서버에서 불일치를 피하면서 컴포넌트 내부의 고유한 값을 생성할 수 있음
#### useTransition
UI 변경을 가로막지 않고 상태를 업데이트할 수 있는 훅

상태 업데이트를 긴급하지 않은 것으로 간주해 무거운 렌더링 작업을 조금 미룰 수 있음
#### useDeferredValue
리액트 컴포넌트 트리에서 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅

디바운스는 고정된 지연 시간을 필요로 하지만 useDeferredValue는 고정된 지연 시간 없이 첫 번째 렌더링이 완료된 이후에 지연된 렌더링을 수행

useTransition은 state 값을 업데이트하는 함수를 감싸서 사용, useDeferredValue는 state 값 자체만을 감싸서 사용
#### useSyncExternalStore
리액트 18 버전에서 useTransition, useDeferredValue 훅으로 렌더링을 일시 중지하거나 미루는 등 최적화가 가능해지면서 동시성 이슈가 발생할 가능성이 생김

state는 위의 훅에서 처리했지만, 외부 데이터 소스의 경우 하나의 state 값이 있음에도 서로 다른 값을 기준으로 렌더링되는 테어링 현상 가능성이 생김

useSyncExternalStore 훅을 통해 외부 데이터 소스의 변경을 추적해야함

#### useInsertionEffect
DOM이 실제로 변경되기 전에 동기적으로 실행되며, 이 훅 내부에 스타일을 삽입하는 코드를 집어넣어 브라우저가 레이아웃을 계산하기 전에 실행하여 자연스러운 스타일 삽입 가능

useLayoutEffect는 모든 DOM의 변경 작업이 다 끝난 이후에 실행

useInsertionEffor는 DOM 변경 작업 이전에 실행
### 10.2.2 react-dom/client
#### createRoot
```
// 이전
import ReactDOM from 'react-dom'
import App from 'App'

const constainer = document.getElementById('root')

ReactDOM.render(<App />, container)

// 18 버전
import ReactDOM from 'react-dom'
import App from 'App'

const constainer = document.getElementById('root')

const root = ReactDom.createRoot(container)
root.render(<App />)
```
#### hydrateRoot
서버 사이드 렌더링 애플리케이션에서 하이드레이션을 하기 위한 새로운 메서드
```
// 이전
import ReactDOM from 'react-dom'
import App from 'App'

const constainer = document.getElementById('root')

ReactDOM.hydrate(<App />, container)

// 18 버전
import ReactDOM from 'react-dom'
import App from 'App'

const constainer = document.getElementById('root')

const root = ReactDom.hydrateRoot(container)
root.render(<App />)
```
### 10.2.3 react-dom/server
#### renderToPipeableStream
리액트 컴포넌트를 HTML로 렌더링하는 메서드

HTML을 점진적으로 렌더링하고 클라이언트에서는 중간에 script를 삽입하는 등의 작업 가능

서버에서는 Suspense를 사용해 빠르게 렌더링이 필요한 부분을 먼저 렌더링할 수 있고, 값비싼 연산으로 구성된 부분은 이후에 렌더링할 수 있음

hydrateRoot를 호출하면 서버에서는 HTML을 렌더링하고, 클라이언트의 리액트에서는 여기에 이벤트만 추가하여 첫 번째 로딩을 빠르게 수행할 수 있음
#### renderToReadableSteam
renderToPipeableStream은 Node.js 환경에서의 렌더링을 위해 사용되고, renderToReadableStream은 웹 스트림을 기반으로 작동

서버 환경이 아닌 클라우드플레어나 디노 같은 웹 스트림을 사용하는 모던 엣지 런타임 환경에서 사용되는 메서드
### 10.2.4 자동 배치(Automatic Batching)
리액트가 여러 상태 업데이트를 하나의 리렌더링으로 묶어서 성능을 향상시키는 방식

한 이벤트가 두 개의 state 업데이트를 할 경우 리액트 17 버전까지는 두 번 리렌더링이 되었으나, 리액트 18에서는 자동배치로 한번만 리렌더링됨
### 10.2.5 더욱 엄격해진 엄격 모드
#### 리액트의 엄격 모드
리액트에서 제공하는 컴포넌트 중 하나로, 잠재적인 버그를 찾는데 도움이 되는 컴포넌트
- 더 이상 안전하지 않은 특정 생명주기를 사용하는 컴포넌트에 대한 경고
- 문자열 ref 사용금지 => 문자열 ref는 여러 컴포넌트에 걸칠 수 있어 충돌 가능성, 실제로 어떤 ref에서 참조되고 있는지 파악 어려움, 리엑트가 계속해서 렌더링 컴포넌트의 ref의 값을 추천해야 하기 때문에 성능 이슈
- findDOMNode에 대한 경고 출력 => 클래스형 컴포넌트 인스턴스에서 실제 DOM 요소에 대한 참조를 가져올 수 있는 메서드, 특정 자식만 렌더링해 트리 추상화 구조를 무너뜨리거나 Fragment 사용으로 첫번째 자식을 반환할 때 어색해지거나 일회성 API로서 자식 컴포넌트가 특정 시점에서 다른 노드를 렌더링할 경우 변경 사항을 추적하기 어려움
- 구 ContextAPI 사용 시 발생하는 경우
- 예상치 못한 부작용(side-effects) 검사 => 다음 내용이 순수한 결과물을 내고 있는지 확인시켜주기 위해 이중 호출
  - 클래스형 컴포넌트의 constructor, render, shouldComponentUpdate, getDerivedStateFromProps
  - 클래스형 컴포넌트의 setSTate의 첫 번째 인수
  - 함수형 컴포넌트의 body
  - useState, useMemo, useReducer에 전달되는 함수
#### 리액트 18에서 추가된 엄격 모드
리액트 팀은 향후 리액트에서 컴포넌트가 마운트 해제된 상태에서도 컴포넌트 내부의 상태값을 유지할 수 있는 기능을 제공할 예정이라고 밝힘

이후에 있을 변경을 위해 StrictMode에서 고의로 useEffect를 두 번 작동시키는 내용을 추가
### 10.2.6 Suspense 기능 강화
리액트 18 버전에서는 Suspense가 실험 단계를 벗어나 정식으로 지원됨
- 마운트되기 직전임에도 effect가 빠르게 실행되는 문제 수정
- 컴포넌트가 보이거나 사라질 때도 effect가 정상적으로 실행
- 서버에서도 Suspense 사용 가능. 서버에서는 일단 fallback 상태의 트리를 클라이언트에 제공하고 불러올 준비가 되면 자연스럽게 렌더링
- 화면이 너무 자주 업데이트되어 시각적으로 방해받는 것을 방지하기 위해 스로틀링이 추가됨
### 10.2.7 인터넷 익스플로러 지원 중단에 따른 추가 폴리필 필요
### 10.2.8 그 밖에 알아두면 좋은 변경사항
### 10.2.9 정리

# 11. Next.js 13과 리액트 18
## 11.1 app 디렉터리의 등장
### 11.1.1 라우팅
#### 라우팅을 정의하는 법
#### layout.js
#### page.js
#### error.js
#### not-found.js
#### loading.js
#### route.js
```
// /api/hello/route.ts
import { NextRequest } from 'next/server'

export async function GET(
  request: Request,  // NextRequest 객체, fetch의 Request를 확장한 Next.js만의 Request. coockie, headers 등뿐만 아니라 nextUrl 같은 주소 객체도 확인 가능 
  context: { params: { id: string } },  // params만을 가지고 있는 객체. 동적 라우팅 파라미터 객체가 포함
) {
  const reponse = await fetch('URL')
  // ...

  return new Response(JSON.stringify(result), {
    status: 200,
    headers: {
      'content-type': 'application/json',
    },
  })
}
```
## 11.2 리액트 서버 컴포넌트
### 11.2.1 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계
SSR은 정적 콘텐츠를 빠르게 제공하고, 서버에 있는 데이터를 손쉽게 제공할 수 있는 반면 사용자의 인터랙션에 따른 다양한 사용자경험을 제공하긴 어렵다

CSR은 사용자의 인터랙션에 따라 정말 다양한 것들을 제공할 수 있지만 서버에 비해 느리고 데이터를 가져오는 것도 어렵다
### 11.2.2 서버 컴포넌트란?
Server Component란 하나의 언어, 하나의 프레임워크, 그리고 하나의 API와 개념을 사용하면서 서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법
### 11.2.3 서버 사이드 렌더링과 서버 컴포넌트의 차이
SSR은 응답받은 페이지 전체를 HTML로 렌더링하는 과정을 서버에서 수행한 후 그 결과를 클라이언트에 내려주고, 이후 하이드레이션 과정을 거쳐 서버의 결과물을 확인하고 이벤트를 붙이는 등의 작업을 수행

서버 컴포넌트를 활용해 서버에서 렌더링할 수 있는 컴포넌트는 서버에서 완성해서 제공받은 다음, 클라이언트 컴포넌트는 SSR로 초기 'HTML으로 바르게 전달 받을 ㅅ ㅜ있음
### 11.2.4 서버 컴포넌트는 어떻게 작동하는가?
1. 서버가 렌더링 요청을 받는다. 서버가 렌더링 과정을 수행해야 하므로 리액트 서버 컴포넌트를 사용하는 모든 페이지는 항상 서버에서 시작된다. 즉, 루트에 있는 컴포넌트는 항상 서버 컴포넌트다.
2. 서버는 받은 요청에 따라 컴포넌트를 JSON으로 직렬화한다. 이때 서버에서 렌더링할 수 있는 것은 직렬화해서 내보내고, 클라이언트 컴포넌트로 표시된 부분은 해당 공간을 플레이스홀더 형식으로 비워드고 나타낸다. 브라우저는 이후에 이 결과물을 받아서 다시 역질렬화한 다음 렌더링을 수행한다.
3. 브라우저가 리액트 컴포넌트 트리를 구성한다. 브라우저가 서버로 스트리밍으로 JSON 결과물을 받았다면 이 구문을 다시 파싱한 결과물을 바탕으로 트리를 재구성해 컴포넌트를 만들어나간다. 클라이언트 컴포넌트를 받았다면 클라이언트에서 렌더링을 진행할 것이고, 서버에서 만들어진 결과물을 받았다면 이 정보를 기반으로 리액트 트리를 그대로 만들 것이다. 그리고 최종적으로 이 트리를 렌더링해 브라우저의 DOM에 커밋한다. 
## 11.3 Next.js에서의 리액트 서버 컴포넌트
### 11.3.1 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitialProps의 삭제
### 11.3.2 정적 렌더링과 동적 렌더링
### 11.3.3 캐시와 mutating, 그리고 revalidating
### 11.3.4 스트리밍을 활용한 점진적인 페이지 불러오기
## 11.4 웹팩의 대항마, 터보팩의 등장(beta)
## 11.5 서버 액션(alpha)
API를 굳이 생성하지 않더라도 함수 수준에서 서버에 직접 접근해 데이터 요청 등을 수행할 수 있는 기능
### 11.5.1 form의 action
### 11.5.2 input의 submit과 image의 formAction
### 11.5.3 startTransition과의 연동
### 11.5.4 server mutation이 없는 작업
### 11.5.5 서버 액션 사용 시 주의할 점
## 11.6 그 밖의 변화
## 11.7 Next.js 13 코드 맛보기
### 11.7.1 getServerSideProps와 비슷한 서버 사이드 렌더링 구현해 보기
### 11.7.2 getStaticProps와 비슷한 정적인 페이지 렌더링 구현해 보기
### 11.7.3 로딩, 스트리밍, 서스펜스
## 11.8 정리 및 주의사항

# 12. 모든 웹 개발자가 관심을 가져야 할 핵심 웹 지표
## 12.1 웹사이트와 성능
사용자들의 기대사항
- 웹사이트를 방문한 목적을 손쉽게 달성해야함
- 첫 번째 목적을 달성하는 데 걸리는 시간이 짧아야함
- 개인정보 유출 등 사고 없이 보안이 철저해야함
## 12.2 핵심 웹 지표란?
Core Web Vital

구글에서 만든 지표로, 웹사이트에서 뛰어난 사용자 경험을 제공하는 데 필수적인 지표를 일컫는 용어

구글에서 핵심 웹 지표로 꼽는 지표
- 최대 콘텐츠풀 페인트(LCP, Largest Contentful Paint)
- 최초 입력 지연(FID, First Input Delay)
- 누적 레이아웃 이동(CLS, Cumulative Layout Shift)
핵심까지는 아니지만, 특정 문제를 진단하는 데 사용할 수 있는 지표
- 최초 바이트까지의 시간(TTFB, Time To First Byte)
- 최초 콘텐츠풀 시간(FCP, First Contentful Paint)
## 12.3 최대 콘텐츠풀 페인트(LCP)
### 12.3.1 정의
페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는데 걸리는 시간
### 12.3.2 의미
### 12.3.3 예제
### 12.3.4 기준 점수
좋은 점수는 2.5초 내 응답, 4초 이내 응답이면 보통, 그 이상은 나쁨으로 판단
### 12.3.5 개선 방안
- 최대 콘텐츠풀페인트 예상 영역에 문자열 넣기
- 브라우저의 프리로드 스캐너에 의해서 먼저 발견되는 img, video 태그 사용
- 이미지 무손실 압축
- loading=lazy 주의: 최대 콘텐츠풀 콘텐츠의 이미지는 중요하지 않은 리소스로 분류해서는 안됨
- fadein과 같은 애니메이션 사용하지 않기
- 클라이언트에서 빌드하지 않기
- 최대 콘텐츠풀 리소스는 가능하면 같은 도메인에서 직접 호스팅하기
## 12.4 최초 입력 지연(FID)
### 12.4.1 정의
사용자가 얼마나 빠르게 웹페이지와의 상호작용에 대한 응답을 받을 수 잇는지 측정하는 지표
### 12.4.1 의미
웹사이트 내부의 이벤트가 반응이 늦어지는 이유는 대규모 렌더링이나 파싱 등으로 브라우저의 메인 스레드가 바쁘기 때문

메인 스레드가 바쁜 경우 자바스크립트 실행 환경은 싱글 스레드이기 때문에 이벤트 리스너와 같은 다른 작업을 실행할 수 없어 지연이 발생

구글이 분류한 사용자 경험 RAIL
- Response: 사용자의 입력에 대한 반응 속도. 50ms 미만으로 이벤트를 처리할 것
- Animation: 애니메이션의 각 프레임을 10ms 이하로 생성할 것
- Idle: 유휴 시간을 극대화해 페이지가 50ms 이내에 사용자 입력에 응답하도록 할 것
- Load: 5초 이내에 콘텐츠를 전달하고 인터랙션을 준비할 것
### 12.4.1 예제
### 12.4.1 기준 점수
좋은 점수는 100ms 이내로 응답, 300ms 이내인 경우 보통, 그 이후의 경우 나쁨으로 처리
### 12.4.1 개선 방안 
- 실행에 오래 걸리는 긴 작업을 분리
- 자바스크립트 코드 최소화
- Google Analytics나 Firebase와 같이 웹페이지의 통계 집계를 위해 넣은 타사 자바스크립트 코드 실행을 지연 불러오기
## 12.5 누적 레이아웃 이동(CLS)
### 12.5.1 정의
페이지의 생명주기 동안 발생하는 모든 예기치 않은 이동에 대한 지표를 계산하는 것
### 12.5.2 의미
사용자 인터랙션이 아닌, 뷰포트 내부의 요소에서 레이아웃의 이동 점수 기록
- 영향분율: 레이아웃 이동이 발생한 요소의 전체 높이와 뷰포트 높이의 비율
- 거리분율: 레이아웃 이동이 발생한 요소가 뷰포트 대비 얼마나 이동했는지
### 12.5.3 예제
### 12.5.4 기준 점수
0.1 이하인 경우 좋음, 0.25 이하인 경우 보통, 그 외에는 개선이 필요한 나쁜 점수
### 12.5.5 개선 방안 
- 삽입이 예상되는 요소를 위한 추가적인 공간 확보
- 폰트 로딩 최적화
- 적절한 이미지 크기 설정
### 12.5.6 핵심 웹 지표는 아니지만 성능 확인에 중요한 지표들
#### TTFE, 최초 바이트까지의 시간
브라우저가 웹페이지의 첫 번째 바이트를 수신하는 데 걸리는 시간

페이지를 요청했을 때 요청이 완전히 완료되는 데 걸리는 시간을 측정하는 것이 아니라 최초의 응답이 오는 바이트까지가 얼마나 걸리는지를 측정하는 지표

600ms 이상걸릴 경우 개선이 필요하다고 간주하며  SSR 애플리케이션에서 주의 깊게 봐야 할 지표
- SSR은 로직을 최적화해 페이지를 최대한 빨리 준비시켜야함. API 호출이 있다면 호출 횟수와 응답 정보의 크기를 최소화하는 등의 최적화 필요
- 웹페이지의 주된 방문객의 국적을 파악해 해당 국적과 가깜게 서버를 위치시키기
- 리액트 SSR이라면 완성된 영역부터 받는 스트리밍 API 사용하기
#### FCP, 최초 콘텐츠풀 페인트
페이지가 로드되기 시작한 시점부터 페이지 콘텐츠의 일부가 화면에 렌더링될 때까지의 시간을 측정

1.8초 이내 좋음, 3.0초 이내는 보통, 그 이후 개선이 필요함으로 보고
- 최초 바이트까지의 시간을 개선
- 렌더링을 가로막는 리소스 최소화
- Above the Fold에 대한 최적화
- 페이지 리다이렉트 최소화
- DOM 크기 최소화
## 12.6 정리 
