## 클로저 (closure)

클로저를 공식문서 mdn에서 검색해보니 "클로저는 함수와 함수가 선언된 어휘적 환경의 조합"이라고 정의를 하였는데 쉽게 이해가 되지 않았다. 과연 선언된 어휘적 환경이 무엇일까?
변수가 코드 내부에서 어디서 선언됐는지가 선언된 어휘적 환경이라 보면 되는데
이를 이해하기 위해서는 변수의 유효 범위, 스코프에 대한 이해가 있어야한다.

### 스코프

스코프의 정의는 식별자가 본인이 선언된 위치에 따라 다른 코드에서 자신이 참조될 수 있을지 없을지 결정되는 것이다.
어떠한 변수가 전역에서 선언된다면 전역 스코프를 갖게되고 특정 함수 안(지역)에 선언된다면 지역 스코프를 갖게 된다.
변수를 참조하려는데 어떠한 변수를 참조해야될지는 변수가 선언된 위치를 봐야된다. 어떠한 변수를 참조해야될지 결정되는 것은 스코프 체인을 알아야 한다.

### 스코프체인

괜찮은 예시가 있어 빗대어 설명해보겠다.
![](https://velog.velcdn.com/images/jutrong/post/f3af4599-c6a2-4105-bfb7-c21b82eb765b/image.jpeg)

높은 망루에서 외부 성벽에 있는 것(변수)을 관찰(참조)하지 못하고 자신의 공간을 먼저 관찰한다. 관찰할 것이 없다면 더 아래층을 보게되고 마지막에는 성벽을 나서서(global) 찾게된다. 제일 위에서 스폰이 되며 내려가는 길만 존재한다.

![](https://velog.velcdn.com/images/jutrong/post/67111f2c-a711-45ad-82e2-ce6c06ac749c/image.jpeg)

자신의 성벽 바깥(global)은 관찰(참조) 가능하지만 다른 성벽의 안의 것은 관찰하지 못한다. 코드 블록의 실행은 독립적이며 실행이 끝나면 더 이상 참조할 수 없기 때문에 더욱이 다른 위치에서 참조할 수 없게 된다.

자신이 속해 있는 지역의 변수들을 참조할 수 있게 되며, 해당 레벨의 참조값이 없다면 상위 레벨 스코프로 참조 값을 찾아 나가는 현상을 스코프 체인이라고 한다.

### 렉시컬 스코프

자바스크립트는 상위 스코프가 결정되는 시점으로 함수가 정의되는 시점에 상위 스코프가 결정되는 스코프를 정적 스코프, 즉 렉시컬 스코프라고 한다.
함수가 호출되는 시점에 상위 스코프가 결정되는 동적 스코프와 달리 함수가 태어나자마자 스코프가 정해진다.
본인의 상위 스코프를 항상 알 수 있게된다. 그 이유는 자바스크립트에서 함수는 태어나면서 내부슬롯에 상위 스코프에 대한 참조를 저장하기 때문 !
![](https://velog.velcdn.com/images/jutrong/post/0f3b85b3-28f5-400a-b858-b64115bdabc9/image.png)

스코프는 앞선 설명을 보고 이해가 되었는데 그러면 다시 클로저는 무엇일까?
"클로저는 함수와 함수가 선언된 어휘적 환경의 조합"
이 정의를 다시 한 번 생각해보자.
사실 다시 봐도 모르겠다. ㅎㅎ...
그러면 코드를 통해서 이해해보자 !

```
const x = 1;

function outer(){
	const x = 10;
    const inner = function(){
    	console.log(x)
    }
    return inner;
}

const jutrong = outer()
jutrong();
```

제일 마지막 줄에 있는 jutrong()은 콘솔에 출력될까?
답은 10이 출력된다.
outer함수는 중첩함수 inner를 jutrong에게 반환하면서 생명주기가 마감하는 함수이다. (지역변수 x또한 생명주기가 마감)
생명주기가 마감했는데 왜 10을 출력할 수 있게 된 것일까?

outer함수는 실행컨텍스트 스택에서 사라지게 되지만 inner함수 객체는 내부 슬롯에 저장된 outer함수 렉시컬 환경을 참조하게 된다.
jutrong에 의해 inner함수를 호출하면 생명주기가 마감한 outer함수 렉시컬 환경의 변수 x를 참조할 수 있다.

내부함수 기준 외부함수가 실행 컨텍스트 스택에서 사라졌지만 내부슬롯에 저장된 상위 스코프내에 식별자를 참조할 수 있게 된다.
이것이 클로저(closure)이다.

정리해보자면
한 중첩함수가 상위 스코프의 식별자를 참조하고 있고,
본인의 외부 함수보다 더 오래 살아있다면 이 중첩함수는 클로저입니다.
그리고 클로저에 의해 참조된 변수 x를 자유 변수라고 한다.

### 클로저의 활용

1. 변수를 직접적으로 노출하지 않음으로써 사용자가 직접 수정하는 것을 막을 수 있다.
2. 전역 스코프를 줄일 수 있다.

클로저를 활용하면 이점도 있지만 주의할 점도 존재한다.
클로저를 사용하는 데에는 비용이 든다. 콜로저는 생성될 때마다 그 선언적 환경을 기억해야 하므로 추가로 비용이 발생한다.
(긴 배열을 어디에 사용하는지 상관없이 일단 해당 내용을 기억해 둬야 하기 때문에 메모리에 큰 배열이 올라가 있다)

클로저에 꼭 필요한 작업만 남겨두지 않는다면 메모리를 불필요하게 잡아먹는 결과를 야기할 수 있고, 마찬가지로 클로저 사용을 적절한 스코프로 가둬두지 않는다면 성능에 악영향을 미친다.

> 클로저는 공짜가 아니므로 클로저를 사용할 때는 주의가 필요하다

우리가 클로저를 이해해야하는 이유중에 하나는 React훅 useState를 이해하기 위해서이다.
useState함수의 호출은 컴포넌트 첫 줄에서 종료되는데, setState는 useState 내부의 최신 값을 어떻게 계속 확인할 수 있을까?
그것은 바로 클로저가 useState내부에서 활용됐기 때문이다.

외부함수(useState)가 반환한 내부 함수(setState)는 외부 함수의 호출이 끝났음에도 자신이 선언된 외부 함수가 선언된 환경(state가 저장되어 있는 어딘가)을 기억하기 때문에 계속해서 state값을 사용할 수 있는 것이다.

## 중요하다고 생각되는 지점/ 추가로 알아두면 좋을 점

- 중요하다고 생각되는 지점

1. 클로저
   클로저가 무엇인가에 대한 답변을 할 수 있어야 된다고 생각
2. 이벤트 루프와 비동기 통신의 이해

```
const foo = () => console.log('First');
const bar = () => setTimeout(() => console.log('Second'), 500);
const baz = () => console.log('Third');

bar();
foo();
baz();
```

위의 코드를 시각화
![](https://velog.velcdn.com/images/jutrong/post/52d1cf35-cbb5-4293-a910-f1750936b9ff/image.gif)

3. 구조분해할당

4. Array 프로토타입 메서드

   React에서의 각각의 메서드 언제 사용하는지

- 추가로 알아두면 좋을 점

  useState는 어떻게 동작할까?

참고글 : https://velog.io/@oneook/스코프와-스코프-체인-JavaScript-Basics
