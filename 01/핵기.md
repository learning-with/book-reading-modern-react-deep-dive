# 모던 리액트 Deep Dive - 1주차: 1장

## 서문

- 리액트에서 `useState`를 사용해야만 컴포넌트에 변경된 상태 값이 반영되는 이유는 무엇일까?
- 컴포넌트 밖에 있는 값을 변경했을 때 그것이 컴포넌트에 반영되지 않는 이유는 무엇일까?
- `Redux`나 `MobX`같은 리액트 생태계 밖에 있는 상태값은 어떻게 렌더링과 함께 동작할 수 있는 것일까?
- `useMemo`나 `useCallback`은 값과 함수를 재사용하고 `memo`를 사용하면 컴포넌트를 재사용할 수 있는데, 이 셋을 사용하는 기준은 무엇일까?
- 함수 덕분에 실제로 재생성되고 있지 않음은 어떻게 알 수 있을까?

## 리액트의 장점

- 명시적인 상태변화

  - 리액트의 상태변화는 `단방향`으로, 그리고 `명시적`으로 이뤄진다.
  - 상태가 변화했다면 그 상태변화를 명시적으로 일으키는 함수만 찾으면 된다

    ```jsx
    // 리액트의 경우 name(상태)가 변경되는 이유는 setName(함수)가 호출될 뿐이다
    // name이 변경된 이유를 찾고 싶다면 setName을 호출하는 곳을 찾으면 된다
    const [name, setName] = useState("");
    ```

- JSX(JavaScript XML): 자바스크립트 문법에 HTML을 약간 가미한 수준이며, 고유의 몇가지 특징만 이해한다면 손 쉽게 JSX 코드를 구현할 수 있다
  - `null`이 아무것도 렌더링하지 않는다는 점
  - 자바스크립트 문법을 `{}`로 감싸야한다는 점

## 리액트의 역사

- 네이티브 앱, 웹 앱, 하이브리드 앱 비교
  ![Alt text](images/image.png)

## 자바스크립트의 동등 비교

- 리액트의 (가상 DOM과 실제 DOM의 비교), (리액트 컴포넌트가 렌더링할지를 판단하는 방법), (변수나 함수의 메모이제이션) 등 모든 작업은 자바스크립트의 동등 비교를 기반으로 한다

## 자바스크립트의 데이터 타입

- `undefined`는 선언됐지만 할당되지 않은 값이고, `null`은 명시적으로 비어있음을 나타내는 값으로 사용하는 것이 일반적이다
- 자바스크립트 문자열의 특징 중 하나는 문자열이 원시 타입이며 변경 불가능하다

## (원시타입과 객체타입의) 값을 저장하는 방식의 차이

- 원시타입과 객체타입은 값을 저장하는 방식이 다르다 -> 동등비교에서 차이를 만든다
  - 원시타입은 불변형태의 값으로 저장된다. 복사할 때 값을 전달한다
  - 객체타입은 변경가능한 형태로 저장된다. 복사할 때 참조를 전달한다

## Object.is

- `===` vs `Object.is`

  ```javascript
  -0 === +0; // true
  Object.is(-0, +0); // false

  Number.NaN === NaN; // false
  Object.is(Number.NaN, NaN); // true

  NaN === 0 / 0; // false
  Object.is(NaN, 0 / 0); // true
  ```

## 리액트에서의 동등비교

- 리액트에서는 `Object.is`를 활용하여 동등비교한다
- `Object.is`는 ES6에서 제공하는 기능이기 때문에 리액트에서는 이를 구현한 폴리필(Polyfill)을 함께 사용한다
- 리액트에서 값을 비교 - `shallowEqual`

  - 리액트에서의 비교를 요약하자면 `Object.is`로 먼저 비교를 수행한 다음에 객체 간 얕은 비교를 한번 더 수행한다

  ```javascript
  if (
    !hasOwnProperty.call(objB, currentKey) ||
    !is(objA[current], objB[currentKey]
  ) {
    return false;
  }
  ```

- 객체의 얕은 비교까지만 구현한 이유는 무엇일까?
  - 객체 안에 객체가 몇 개까지 있을지 알 수 없으므로 성능에 악영향

## 함수선언문

- 함수 리터럴은 코드 문맥에 따라 전자와 같은 선언문으로도, 후자와 같은 표현식으로도 사용될 수 있다
- 함수의 호이스팅은 함수에 대한 선언을 실행 전에 미리 메모리에 등록하는 작업이다 -> 따라서 코드의 순서에 상관없이 정상적으로 함수가 호출된다

## 화살표 함수

- 화살표 함수에서는 `constructor`를 사용할 수 없다
- 화살표 함수에서는 `arguments`가 존재하지 않는다
- 화살표 함수 내부에서 `this`를 참조하면 상위 스코프의 `this`를 그대로 따르게 된다

## 즉시 실행 함수

- 즉기실행함수의 특성은 글로벌 스코프를 오염시키지 않는 독립적인 함수 스코프를 운용할 수 있다
  - 함수의 선언과 실행이 바로 그 자리에서 끝나기 때문에 즉시 실행 함수 내부의 값은 그 함수 내부가 아니고서는 접근이 불가능
- 재사용되지 않는 함수라면 즉시실행함수의 사용을 검토해보자

## 함수의 부수 효과를 최대한 억제하라

- 함수의 부수효과(side-effect)란 함수 내의 작동으로 인해 함수가 아닌 함수 외부에 영향을 끼치는 것
  - 순수함수: 부수효과가 없는 함수
    순수함수는 부수효과가 없고, 언제 어디서나 어떠한 상황에서든 동일한 인수를 받으면 동일한 결과를 반환
  - 비순수함수: 부수효과가 존재하는 함수
- 부수효과를 만드는 것은 피할 수 없는 요소지만 부수효과를 최대한 억제할 수 있는 방향으로 함수를 설계해야한다.
  - e.g. 리액트에서는 부후효과를 처리하는 훅인 `useEffect`의 작동을 최소화하는 것
- 자바스크립트 함수에서는 가능한 부수 효과를 최소화하고, 함수의 실행과 결과를 최대한 예측가능하도록 설계해야 한다.
- 리액트에서 사용하는 `useEffect`나 `useCallback` 등의 훅에 넘겨주는 콜백 함수에 네이밍을 붙여준다면 가독성에 도움이 된다

  ```javascript
  useEffect(function apiRequest() {
    // ... do something
  }, []);
  ```

## 프로퍼티

- 인스턴스 생성시 `constructor` 내부에는 빈 객체가 할당돼 있는데 이 빈 객체에 프로퍼티의 키와 값을 넣어 활용할 수 있다

## 정적 메서드

- 정적 메서드 내부의 `this`는 클래스로 생성된 인스턴스가 아닌, 클래스 자신을 가리킨다

## 클로저

- 클로저는 함수와 함수가 선언된 어휘적 환경(Lexical Scope)의 조합
- `선언된 어휘적 환경`이란 변수가 코드 내부에서 어디서 선언됐는지를 말한다

## 변수의 유효범위, 스코프

- 변수의 유효범위(스코프)에 따라 어휘적 환경이 결정된다.
- 전역스코프
  - 전역 레벨에 선언하는 것
  - 전역 스코프에서 변수를 선언하면 어디서든 호출가능하다
  - `window`객체 (브라우저), `global`객체(Node.js)에 전역 스코프가 바인딩된다
- 함수코프

## 리액트에서의 클로저

- `useState` 함수의 호출은 종료되었는데 `setState`는 `useState` 내부의 최신 값을 어떻게 계속해서 확인할 수 있을까?
- 그것은 외부함수(useState) 가 반환한 내부함수(setState)는 외부함수(useState)의 호출이 끝났음에도 자신이 선언된 외부함수가 선언된 환경을 기억하기 때문에 계속해서 state 값을 사용할 수 있는 것

## 이벤트 루프란?

- 이벤트 루프는 자바스크립트 표준에 나와있는 내용은 아니다
- 이벤트 루프는 자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치
- 이벤트 루프의 역할은 (호출 스택에 실행 중인 코드가 있는지), 그리고 (태스트 큐에 대기 중인 함수가 있는지) 반복해서 확인한다. 만약 호출 스택이 비었다면 태스트 큐에 대기 중인 작업이 있는지 확인하고, 이 작업을 실행가능한 오래된 것부터 순차적으로 꺼내와서 실행
  - 호출스택(call stack)은 자바스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아두는 스택
- '코드를 실행하는 것'과 '호출 스택이 비어있는지 확인하는 것'이 단일 스레드에서 일어난다 -> 한 스레드에서 순차적으로 일어난다

## 비동기 함수

- 비동기 함수는 태스트 큐가 할당되는 별도의 스레드에서 수행된다
- 별도의 스레드에서 태스트 큐에 작업을 할당해 처리하는 것은 브라우저나 Node.js 의 역할이다
- 자바스크립트 코드 실행은 싱글 스레드에서 이루어지지만 외부 web API 등은 모두 자바스크립트 코드 외부에서 실행되고 콜백이 태스크 큐로 들어간다

## 태스크 큐

- 태스트 큐란 실행해야 할 태스크의 집합을 의미한다
- 이벤트 루프는 태스트 큐를 한 개 이상 가지고 있다

## 마이크로 태스크 큐

- 이벤트 루프는 하나의 마이크로 태스크 큐를 갖고 있는데, 태스크 큐와는 다른 태스크를 처리한다
- 마이크로 태스크 큐는 기존 태스크 큐보다 우선권을 갖는다
  - 마이크로 태스크 큐가 빌 때까지 기존 태스크 큐의 실행은 뒤로 미루어진다

## 렌더링과 이벤트 루프

- 브라우저는 기본적으로 화면을 매 16.6 밀리세컨드, 즉 1초에 60 프레임을 repaint 하는게 이상적입니다. 하지만 자바스크립트로 제약을 받습니다.
- 스택에 코드가 있다면 렌더링을 못합니다. 렌더링도 하나의 콜백처럼 행동하니까요. 스택이 비워질때 까지 기다려야 하는겁니다.
- 렌더는 콜백에 비해 더 높은 우선순위를 가진다. 매 16 millisecond 마다 큐에 렌더가 들어가고, 스택이 깨끗해진 후에야 렌더링을 합니다
- 자바스크립트 엔진은 매크로태스크 하나를 처리할 때마다 또 다른 매크로태스크나 렌더링 작업을 하기 전에 마이크로태스크 큐에 쌓인 마이크로태스크 전부를 처리합니다.
  ![Alt text](images/image-1.png)

## 배열 구조 분해 할당

- `useState`가 객체가 아닌 배열을 반환하는 이유는 무엇일까?
  - 객체 구조 분해 할당은 사용하는 쪽에서 원하는 이름으로 변경하는 것이 번거롭다
  - 배열 구조 분해 할당은 자유롭게 이름을 선언할 수 있다
- 자바스크립트에서 기본값을 사용할 수 있는 경우는 `undefined`일 때 뿐이다

## 객체의 전개구문

- 객체 전개 구문에 있어 순서가 중요하다.
  - 전개 구문 이후에 값 할당이 있으면 전개구문이 할당한 값을 덮어쓰겠지만

## 트랜스파일

- 객체 구조 분해 할당의 경우 트랜스파일을 거치면 번들링 크기가 상대적으로 커진다
  - alt. `lodash.omit`이나 `ramda.omit` 사용을 고려
- 객체 전개 연산자 또한 트랜스파일되면 상대적으로 번들링이 커진다
  - 객체의 속성값 및 설명자 확인, 심벌 체크 등으로 인하여

## Array 프로토타입의 메서드

- `Array.prototype.map`은 인수로 전달받은 배열과 똑같은 길이의 새로운 배열을 반환하는 메서드이다
- `Array.prototype.filter` 메서드는 콜백함수를 인수로 받는데, 이 콜백 함수에서 truthy 조건을 만족하는 경우에만 해당 원소를 반환하는 메서드다. 새로운 배열 반환
- `Array.prototype.forEach`는 실행되는 순간 에러를 던지거나 프로세스를 종료하지 않는 이상 이를 멈출 수 없다

## 타입스크립트란?

- 타입스크립트는 타입체크를 정적으로 런타임이 아닌 빌드(트랜스파일) 타임에 수행할 수 있게 해준다
- 타입스크립트는 자바스크립트의 슈퍼셋으로서 함수의 반환타입, 배열, enum 등 타입 관련 작업들을 처리해준다

## any 대신 unknown을 사용하자

- `any`는 자바스크립트에서 타입스크립트로 넘어가는 과도기와 같은 예외적인 경우에만 사용
- 불가피하게 아직 타입을 단정할 수 없는 경우에는 `unknown`을 사용
  - `typeof`를 사용해서 해당 `unknown` 값이 우리가 원하는 타입일 때만 의도적으로 작동하도록 해야한다
- `never`는 코드상으로 존재가 불가능한 타입을 나타낼 때 사용한다
  - 어떠한 props도 받아들이지 않는다는 의미로 활용가능

## in

- `in`은 `property in object`로 사용되는데, 어떤 객체에 키가 존재하는지 확인하는 용도로 사용한다

## 제네릭

- 제네릭은 함수나 클래스 내부에서 단일 타입이 아닌 다양한 타입에 대응할 수 있도록 도와준다
- 제네릭을 사용하면 타입만 다른 비슷한 작업을 하는 컴포넌트를 단일 제네릭 컴포넌트로 선언해 간결하게 작성할 수 있다
- `useState`에 제네릭으로 타입을 설정하면 `state`사용과 기본값 선언을 더 명확하게 할 수 있다
  - `useState()`와 같은 형식으로 기본값을 넘기지 않으면 값을 `undefined`로 추론한다

## 인덱스 시그니처

- 인덱스 시그니처란 객체의 키를 정의하는 방식
- `Record<Key, Value>`를 사용하면 객체의 타입에 각각 원하는 키와 값을 넣을 수 있다

## 덕타이핑

- 객체의 타입을 확인하기보다는 객체의 속성과 메서드의 존재여부로 객체를 판단하는 것
