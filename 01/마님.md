# 01. 리액트 개발을 위해 꼭 알아야 할 자바스크립트
## 1.1 자바스크립트의 동등 비교
### 1.1.1 자바스크립트의 데이터 타입
### 1.1.2 값을 저장하는 방식의 차이
원시 값은 변수 할당 시점에 메모리 영역을 차지하고 저장

객체는 변경 가능한 형태로 값이 아닌 참조를 전달 => 값이 같더라도 참조하는 곳이 다를 수 있음

객체 내의 프로퍼티의 값을 비교하거나, 객체에 다른 객체를 할당한 경우는 true

- 객체 간에 비교가 발생하면, 이 객체 간의 비교는 내부의 값이 같다 하더라도 결과는 대부분 true가 아닐 수 있다

### 1.1.3 자바스크립트의 또 다른 비교 공식, Object.is
'=='와 달리, 타입이 다르더라도 강제로 형변환하지 않음

'==='에 비해, 조금 더 정확한 비교
```
-0 === +0  // true
Object.is(-0, +0)  // false

Number.NaN === NaN  // false
Object.is(Number.NaN, NaN)  // true

NaN === 0 / 0  // false
Object.is(NaN, 0 / 0)  //true
```

### 1.1.4 리액트에서의 동등 비교
리액트는 ObjectIs를 기반으로 동등 비교를 하는 shallowEqual 함수를 만들어 사용

Object.is로 먼저 비교 후, 객체 간 얕은 비교를 한번 더 수행 => JSX props의 props만 일차적으로 비교

### 1.1.5 정리

## 1.2 함수
### 1.2.1 함수란 무엇인가?
### 1.2.2 함수를 정의하는 4가지 방법
#### 함수 선언문
- 함수의 호이스팅, 메모리에 함수를 등록
#### 함수 표현식
- 함수의 호이스팅, undefined로 초기화, 런타임 시점에 함수 할당
#### Function 생성자
- 함수의 클로저가 생성되지 않음, 자주 사용X
#### 화살표 함수
- constructor 사용 불가능. 생성자 함수로 화살표 함수를 사용할 수 없음
- arguments 없음
- this 바인딩, 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 따름. 일반 함수의 경우 전역 객체(런타임 시점에 결정되는 this)를 가리킴
  
### 1.2.3 다양한 함수 살펴보기
#### 즉시 실행 함수Immediately Invoked Function Expression, IIFE
- 재사용하지 않는 함수임을 명시
- 글로벌 스코프를 오염시키지 않는 독립적인 함수 스코프 운용가능
#### 고차 함수High Order Function 
- Array.prototype.map
### 1.2.4 함수를 만들 때 주의해야 할 사항
- 함수의 부수 효과side-effect를 최대한 억제하기
- 함수 크기 줄이기
- 누구나 이해할 수 있는 변수명 사용하기
## 1.3 클래스
### 1.3.1 클래스란 무엇인가?
#### 클래스
특정한 형태의 객체를 반복적으로 만들기 위해 사용되는 것
#### constructor
생성자, 객체를 생성하는데 사용하는 특수한 메서드. 단 하나만 존재 가능. 생략 가능.
#### 프로퍼티
클래스로 인스턴스를 생성할 때 내부에 정의할 수 잇는 속성값

기본적으로 인스턴스 생성 시 constructor 내부에는 빈 객체가 할당됨. 이 객체에 프로퍼티의 키와 값을 넣어 활용

`#`을 붙여서 private 선언

타입스크립트에서 private, protected, public 사용가능
#### getter와 setter
getter: 클래스에서 무언가 값을 가져올 때 사용

setter: 클래스 필드에 값을 할당할 때 사용
#### 인스턴스 메서드
클래스 내부에서 선언한 메서드, 프로토타입 메서드(자바스크립트의 prototype에 선언됨)
```
const myCar - new Car('자동차')
Object.getPrototypeOf(myCar)  // {constructor: f, hello: f}
```
#### 정적 메서드
클래스의 인스턴스가 아닌 이름으로 호출할 수 있는 메서드
#### 상속
extends 기존 클래스를 상속받아서 자식 클래스에서 이 상속받은 클래스를 기반으로 확장
### 1.3.2 클래스와 함수의 관계
### 1.3.3 정리 

## 1.4 클로저
### 1.4.1 클로저의 정의
함수와 함수가 선언된 어휘적 환경의 조합
### 1.4.2 변수의 유효 범위, 스코프
### 1.4.3 클로저의 활용
- 사용자가 직접 수정하는 것을 막음
- 접근하는 경우를 제한해 로그를 남길 수 있음
useState 호출이 종료되었음에도, 엄데이트 함수는 계속해서 내부의 최신값을 알고 있기 때문에 사용가능
### 1.4.3 주의할 점
- 클로저는 생성될 때마다 그 선언적 환경을 기억해야 하므로 추가로 비용이 발생
### 1.4.5 정리

## 1.5 이벤트 루프와 비동기 통신의 이해
### 1.5.1 싱글 스레드 자바스크립트
멀티 스레딩은 메모리 공유로 여러가지 작업을 동시에 수행 가능

싱글 스레드는 하나의 작업이 끝나기 전까지는 뒤이은 작업이 실행되지 않는다

동시에 같은 자원에 접근하면 타이밍 이슈가 발생할 수 있고, 브라우저의 DOM 표시에 큰 문제를 야기할 수 있어 싱글 스레드를 선택(1995년 당시)
### 1.5.2 이벤트 루프란?
자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치

call stack에 들어가고, 실행되고, 제거됨 => call stack이 비어있는지 확인하고, 자바스크립트 엔진을 통해 실행시킴

비동기 함수의 경우 타이머 이벤트가 실행되며 태스크큐에 들어가고 call stack에서 제거됨 => call stack이 비어있을때, 태스크 큐의 비동기함수를 call stack에 들여보냄

태스크 큐는 실행 가능한 가장 오래된 테스크를 가져와야하기 때문에 set 형태

즉, 자바스크립트 코드 실행은 싱글 스레드에서 이루어지지만 이러한 외부 Web API 등은 모두 자바스크립트 코드 외부에서 실행되고 콜백이 태스크 큐로 들어감
### 1.5.3 태스크 큐와 마이크로 태스크 큐
마이크로 태스크에는 Promise가 들어가며, 기존 태스크 큐보다 우선권을 가짐

즉, setTimeout과 setInterval은 Promise보다 늦게 실행됨

브라우저에 렌더링하는 작업은 마이크로 태스크 큐와 태스크 큐 사이에서 일어남
### 1.5.4 정리

## 1.6 리액트에서 자주 사용하는 자바스크립트 문법
### 1.6.1 구조 분해 할당
- 배열의 구조 분해 할당의 경우 undifined인 경우에만 기본값 가능
### 1.6.2 전개 구문
- 전개 구문의 경우 값만 복사했을 뿐, 참조는 다르므로 다른 값임
### 1.6.3 객체 초기자
### 1.6.4 Array 프로토타입의 메서드: map, filter, reduce, forEach
### 1.6.5 삼항 조건 연산자
### 1.6.6 정리

## 1.7 선택이 아닌 필수, 타입스크립트
### 1.7.1 타입스크립트란?
TypeScript is JavaScript with syntax for types

런타임에 에러체크가능한 동적 언어 JS의 한계를 벗어나 빌드 타입에 타입 체크를 수행
### 1.7.2 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법
- any 대신 unknown을 사용하자 => typeof를 사용하여 원하는 타입에만 작동할수있도록
- 타입 가드를 적극 활용하자 instanceof, typeof, in
- 제네릭
- 인덱스 시그니처
### 1.7.3 타입스크립트 전환 가이드
- tsconfig.json 먼저 작성하기
- JSDoc과 @ts-check를 활용해 점진적으로 전환하기
- 타입 기반 라이브러리 사용을 위해 @types 모듈 설치하기
- 파일 단위로 조금씩 전환하기
### 1.7.4 정리
