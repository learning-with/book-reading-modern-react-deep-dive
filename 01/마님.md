# 01. 리액트 개발을 위해 꼭 알아야 할 자바스크립트
## 1.1 자바스크립트의 동등 비교
### 1.1.1 자바스크립트의 데이터 타입
### 1.1.2 값을 저장하는 방식의 차이
원시 값은 변수 할당 시점에 메모리 영역을 차지하고 저장

객체는 변경 가능한 형태로 값이 아닌 참조를 전달 => 값이 같더라도 참조하는 곳이 다를 수 있음

객체 내의 프로퍼티의 값을 비교하거나, 객체에 다른 객체를 할당한 경우는 true

- 객체 간에 비교가 발생하면, 이 객체 간의 비교는 내부의 값이 같다 하더라도 결과는 대부분 true가 아닐 수 있다

### 1.1.3 자바스크립트의 또 다른 비교 공식, Object.is
'=='와 달리, 타입이 다르더라도 강제로 형변환하지 않음

'==='에 비해, 조금 더 정확한 비교
```
-0 === +0  // true
Object.is(-0, +0)  // false

Number.NaN === NaN  // false
Object.is(Number.NaN, NaN)  // true

NaN === 0 / 0  // false
Object.is(NaN, 0 / 0)  //true
```

### 1.1.4 리액트에서의 동등 비교
리액트는 ObjectIs를 기반으로 동등 비교를 하는 shallowEqual 함수를 만들어 사용

Object.is로 먼저 비교 후, 객체 간 얕은 비교를 한번 더 수행 => JSX props의 props만 일차적으로 비교

### 1.1.5 정리

## 1.2 함수
### 1.2.1 함수란 무엇인가?
### 1.2.2 함수를 정의하는 4가지 방법
#### 함수 선언문
- 함수의 호이스팅, 메모리에 함수를 등록
#### 함수 표현식
- 함수의 호이스팅, undefined로 초기화, 런타임 시점에 함수 할당
#### Function 생성자
- 함수의 클로저가 생성되지 않음, 자주 사용X
#### 화살표 함수
- constructor 사용 불가능. 생성자 함수로 화살표 함수를 사용할 수 없음
- arguments 없음
- this 바인딩, 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 따름. 일반 함수의 경우 전역 객체(런타임 시점에 결정되는 this)를 가리킴
  
### 1.2.3 다양한 함수 살펴보기
#### 즉시 실행 함수Immediately Invoked Function Expression, IIFE
- 재사용하지 않는 함수임을 명시
- 글로벌 스코프를 오염시키지 않는 독립적인 함수 스코프 운용가능
#### 고차 함수High Order Function 
- Array.prototype.map
### 1.2.4 함수를 만들 때 주의해야 할 사항
- 함수의 부수 효과side-effect를 최대한 억제하기
- 함수 크기 줄이기
- 누구나 이해할 수 있는 변수명 사용하기
## 1.3 클래스
### 1.3.1 클래스란 무엇인가?
#### 클래스
특정한 형태의 객체를 반복적으로 만들기 위해 사용되는 것
#### constructor
생성자, 객체를 생성하는데 사용하는 특수한 메서드. 단 하나만 존재 가능. 생략 가능.
#### 프로퍼티
클래스로 인스턴스를 생성할 때 내부에 정의할 수 잇는 속성값
기본적으로 인스턴스 생성 시 constructor 내부에는 빈 객체가 할당됨. 이 객체에 프로퍼티의 키와 값을 넣어 활용
`#`을 붙여서 private 선언
타입스크립트에서 private, protected, public 사용가능
#### getter와 setter
getter: 클래스에서 무언가 값을 가져올 때 사용
setter: 클래스 필드에 값을 할당할 때 사용
#### 인스턴스 메서드
클래스 내부에서 선언한 메서드, 프로토타입 메서드(자바스크립트의 prototype에 선언됨)
```
const myCar - new Car('자동차')
Object.getPrototypeOf(myCar)  // {constructor: f, hello: f}
```
#### 정적 메서드
클래스의 인스턴스가 아닌 이름으로 호출할 수 있는 메서드
#### 상속
extends 기존 클래스를 상속받아서 자식 클래스에서 이 상속받은 클래스를 기반으로 확장
### 1.3.2 클래스와 함수의 관계
### 1.3.3 정리 

## 1.4 클로저
### 1.4.1 클로저의 정의
함수와 함수가 선언된 어휘적 환경의 조합
### 1.4.2 변수의 유효 범위, 스코프
### 1.4.3 클로저의 활용
- 사용자가 직접 수정하는 것을 막음
- 접근하는 경우를 제한해 로그를 남길 수 있음
useState 호출이 종료되었음에도, 엄데이트 함수는 계속해서 내부의 최신값을 알고 있기 때문에 사용가능
### 1.4.3 주의할 점
- 클로저는 생성될 때마다 그 선언적 환경을 기억해야 하므로 추가로 비용이 발생
### 1.4.5 정리

## 1.5 이벤트 루프와 비동기 통신의 이해
### 1.5.1 싱글 스레드 자바스크립트
### 1.5.2 이벤트 루프란?
### 1.5.3 태스크 큐와 마이크로 태스크 큐
### 1.5.4 정리

## 1.6 리액트에서 자주 사용하는 자바스크립트 문법
### 1.6.1 구조 분해 할당
- 배열의 구조 분해 할당의 경우 undifined인 경우에만 기본값 가능
### 1.6.2 전개 구문
- 전개 구문의 경우 값만 복사했을 뿐, 참조는 다르므로 다른 값임
### 1.6.3 객체 초기자
### 1.6.4 Array 프로토타입의 메서드: map, filter, reduce, forEach
### 1.6.5 삼항 조건 연산자
### 1.6.6 정리

## 1.7 선택이 아닌 필수, 타입스크립트
### 1.7.1 타입스크립트란?
### 1.7.2 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법
- any 대신 unknown을 사용하자
- 타입 가드를 적극 활용하자
- 제네릭
- 인덱스 시그니처
### 1.7.3 타입스크립트 전환 가이드
- tsconfig.json 먼저 작성하기
- JSDoc과 @ts-check를 활용해 점진적으로 전환하기
- 타입 기반 라이브러리 사용을 위해 @types 모듈 설치하기
- 파일 단위로 조금씩 전환하기
### 1.7.4 정리
